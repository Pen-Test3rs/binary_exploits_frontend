import React, { useEffect, useState } from 'react';
import TaskCard from './taskCard';
import Pagination from '../pagination/pagination';
import { Levels } from './levels';
import { tasksService } from '../../services/tasksService';
import { apiUrls } from '../../utils/apiUrls';
import { TasksList } from '../../models/task';

const TasksComponent = () => {
    const [tasks, setTasks] = useState<TasksList[]>([]);
    useEffect(() => {
        (async () => {
            tasksService
                .get(apiUrls.TASKS)
                .then((a) => {
                    setTasks(a);
                })
                .catch((err) => {
                    //TODO: handle error
                });
        })();
    }, []);

    /*let cards = [...Array(13)].map((e, i) => (
      <TaskCard
          key={i}
          category={'Przepełnienie bufora'}
          text={
              'Przepełnienie bufora – błąd programistyczny polegający na zapisaniu do wyznaczonego obszaru pamięci większej ilości danych niż zarezerwował na ten cel programista. Taka sytuacja prowadzi do zamazania danych znajdujących się w pamięci bezpośrednio za buforem, a w rezultacie do błędnego działania programu.'
          }
          level={Levels.Medium}
      />
  ));*/

    for (let i = 3; i < 32; i++)
        tasks.push({
            id: i,
            name_id: 'buffer_overflow',
            labels: [],
            title: 'Przepełnienie bufora',
            level: Levels.Hard,
            points: 100,
            status: 'ok'
        });

    function wrapTasks() {
        return tasks.map((task) => <TaskCard key={task.id} taskData={task} />);
    }

    return (
        <>
            <div className="flex flex-wrap w-full">
                <Pagination data={wrapTasks()} pageLimit={Math.min(Math.ceil(tasks.length / 6), 5)} dataLimit={6} />
            </div>
        </>
    );
};

export default TasksComponent;
